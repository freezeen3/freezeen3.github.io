---
section_title: Protocl Analysis and Kerberos
---

## Protocols

Definition
- every step clearly defined
- every party involved knows the steps
- participants don't think

### Attacks

Common types
- Replay
    - Attacker resends an intercepted message, even if recipient has received once from legit sender before &rarr; cannot tell if message is still valid
- Reflection
    - The attacker can send message to a usual sender, making the usual sender a receiver
    - Usual
        1. A &rarr; B: x
        2. B &rarr; A: y
    - Reflected
        1. A &rarr; C\[B]: x
        2. C\[B] &rarr; A: x
        3. A &rarr; C\[B]:
        4. C\[B] &rarr; A or B: 


## Liveliness Protocol Case Studies
Goal: A wants to check B is alive currently, need to satisfy
- Reply is generated by B
- Reply by B is fresh
- Reply by B corresponds to a particular request by A

Typical Assumptions
- MAC is secure
- Secret key between two parties is only known to them
- Random number generator is good i.e. cannot be predicted what number will be generated at future timestamps

### Protocol 1: RNGStamp
1. A &rarr; B: &nbsp; hello \|\| ID<sub>A</sub> \|\| r<sub>A</sub>
2. B &rarr; A: &nbsp; r<sub>A</sub> \|\| ID<sub>A</sub> \|\| OK \|\| MAC<sub>K</sub>(r<sub>A</sub> \|\| ID<sub>A</sub> \|\| OK)

Analysis:
- Good
- Has random number $\implies$ freshness + corresponds to particular request generated by A
    - freshness since highly unlikely to be able to generate the same r<sub>A</sub> at another timestamp $\implies$ same effect as attaching timestamp
- MAC $\implies$ after A receives from B, A computes MAC of (r<sub>A</sub> \|\| ID<sub>A</sub> \|\| OK) and check against the concatenated MAC. Since only other person that knows K is B, A ensures the message is generated by B if the MAC's match.
- Is ID<sub>A</sub> necessary? 
    - Lets B know which K to use, and who to send message back to
- Can we replace r<sub>A</sub> with T<sub>A</sub>?
    - Yes, T<sub>A</sub> and r<sub>A</sub> serve the same function of ensuring freshness and particular request association
        1. A &rarr; B: &nbsp; hello \|\| ID<sub>A</sub> \|\| T<sub>A</sub>
        2. B &rarr; A: &nbsp; T<sub>A</sub> \|\| ID<sub>A</sub> \|\| OK \|\| MAC<sub>K</sub>(T<sub>A</sub> \|\| ID<sub>A</sub> \|\| OK)
    - However one possible attack of covering the death of B using timestamp:
        1. Attacker C\[A\] &rarr; B: &nbsp; hello \|\| ID<sub>A</sub> \|\| T<sub>A'</sub> where T<sub>A'</sub> is later than T<sub>A</sub>
        2. B &rarr; C\[A\]: &nbsp; T<sub>A'</sub> \|\| ID<sub>A</sub> \|\| OK \|\| MAC<sub>K</sub>(T<sub>A'</sub> \|\| ID<sub>A</sub> \|\| OK)
        3. C kills B, and waits for A to send message to B at time T<sub>A'</sub>
        4. C\[B\] &rarr; A: &nbsp; T<sub>A'</sub> \|\| ID<sub>A</sub> \|\| OK \|\| MAC<sub>K</sub>(T<sub>A'</sub> \|\| ID<sub>A</sub> \|\| OK), A thinks B is still alive

### Protocol 2: ID-less
1. A &rarr; B: &nbsp; hello \|\| ID<sub>A</sub> \|\| r<sub>A</sub>
2. B &rarr; A: &nbsp; r<sub>A</sub> \|\| OK \|\| MAC<sub>K</sub>(r<sub>A</sub> \|\| OK)

Analysis:
- Lack of ID: Prone to reflection attack
    1. A &rarr; C\[B]: &nbsp; hello \|\| ID<sub>A</sub> \|\| r<sub>A</sub>
    2. reflect back with exact same msg C\[B] &rarr; A: &nbsp; hello \|\| ID<sub>A</sub> \|\| r<sub>A</sub>
    3. A &rarr; C\[B]: &nbsp; r<sub>A</sub> \|\| OK \|\| MAC<sub>K</sub>(r<sub>A</sub> \|\| OK)
    4. reuse C\[B] &rarr; A: &nbsp; r<sub>A</sub> \|\| OK \|\| MAC<sub>K</sub>(r<sub>A</sub> \|\| OK) $\implies$ A tricked into thinking established communication with B i.e. B is alive


### Protocol 3: Encrypt-whole
1. A &rarr; B: &nbsp; hello \|\| ID<sub>A</sub> \|\| r<sub>A</sub>
2. B &rarr; A: &nbsp; E<sub>K</sub>(r<sub>A</sub> \|\| ID<sub>A</sub> \|\| OK)

Analysis:
- Good, strong as Protocol 1
- Has r for freshness + request linkage, ID to prevent reflection
- The encryption should have mechanism to prevent block manipulation

### Protocol 4: Timeless Incoming
1. A &rarr; B: &nbsp; hello \|\| ID<sub>A</sub>
2. B &rarr; A: &nbsp; T<sub>B</sub> \|\| ID<sub>A</sub> \|\| OK \|\| MAC<sub>K</sub>(T<sub>B</sub> \|\| ID<sub>A</sub> \|\| OK)

Analysis:
- If multiple replies are sent to A (from B or not), how can A know which request by A the reply by B corresponds to? Lack info in request by A, so A cannot verify in reply
- Replay attacks possible: send the reply to A after saving B's reply, if A does not check T<sub>B</sub> with current time. But even if check, not sure if it corresponds to an older request by A or not
- Reflection possible?
    - No. If attacker after intercepting msg from A to B, reflects it back to A, A replies with a msg containing A's ID, and the attacker if using this ID to send back to A, then A will know it is something wrong as it should not contain A's own ID

### Protocol 5: Signature-based
1. A &rarr; B: &nbsp; hello \|\| ID<sub>A</sub> \|\| r<sub>A</sub>
2. B &rarr; A: &nbsp; r<sub>A</sub> \|\| ID<sub>A</sub> \|\| OK \|\| E<sub>Kpri(B)</sub>(r<sub>A</sub> \|\| ID<sub>A</sub> \|\| OK)

Assume signature scheme is strong, secure mechanism exists for digital signature verification

Analysis:
- Good, as strong as protocol 1
- Uses signature instead of MAC